#####  List Set Queue Map四者区别？
* List：存储的元素是有序的、可重复的,且允许存在多个Null对象，可以使用迭代器取出所有元素。
* Set: 存储的元素是无序、不可重复的，仅允许存在一个Null对象。
* Queue：先进先出的数据结构(区别于栈)，存储的元素是有序的、可重复的
* Map：使用键-值对存储，key是无序、不可重复，value是无序、可重复的


#####  ArrayList和Array(数组)的区别？
 * ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活。
 * ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。
 * ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。
 * ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。Array 可以直接存储基本类型数据，也可以存储对象。
 * ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。
 * ArrayList创建时不需要指定大小，而Array创建时必须指定大小。
 
 
 #####  集合常见方法时间复杂度
 数组 Array
 访问：O(1)
 查找(未排序)：O(n)
 查找(已排序)：O(log n)
 插入/删除：不支持
 
 数组列表 ArrayList
 添加： O(1)
 删除：O(n)
 查询：O(n)
 求长：O(1)
 
 链接列表 LinkedList
 插入：O(n)
 删除：O(n)
 查找：O(n)
 
 
栈 Stack
压栈：O(1)
出栈：O(1)
栈顶：O(1)
查找：O(n)

队列 Queue/Deque/Circular Queue
插入：O(1)
移除：O(1)
求长：O(1)

##### 比较ArrayList和LinkedList的异同

内部实现：

ArrayList基于动态数组实现，内部使用数组来存储元素。当数组容量不足时，会进行扩容操作。
LinkedList基于双向链表实现，每个节点包含对前一个节点和后一个节点的引用。
访问效率：

ArrayList支持随机访问，通过索引可以快速获取元素，时间复杂度为O(1)。但在插入和删除元素时，需要移动其他元素，时间复杂度为O(n)。
LinkedList对于随机访问效率较低，需要从头或尾开始遍历链表，时间复杂度为O(n)。但在插入和删除元素时，由于只需要改变节点的引用，时间复杂度为O(1)。
空间复杂度：

ArrayList的空间复杂度是O(n)，因为它需要预先分配一定大小的数组空间。
LinkedList的空间复杂度也是O(n)，因为每个节点都需要额外的空间存储前后节点的引用。
插入和删除操作：

在ArrayList中，插入和删除元素涉及到数组元素的移动，所以在中间插入或删除元素时效率较低。
在LinkedList中，由于只需改变节点的引用，插入和删除元素效率较高，尤其是在中间位置。
迭代器性能：

使用迭代器遍历ArrayList的效率较高，因为可以直接根据索引获取元素。
使用迭代器遍历LinkedList的效率较低，因为需要按顺序遍历整个链表。
综上所述，当需要频繁进行随机访问操作时，选择ArrayList更为合适；当需要频繁进行插入和删除操作，并且对访问效率要求不高时，选择LinkedList可能更适合。在选择使用哪种集合类时，需要根据具体的业务场景和需求来权衡各自的优缺点。


#####  比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同
  
  HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
  HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。
  LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。
  TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
  底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。


##### ArrayDeque和ArrayList都是Java中的集合类，但它们在应用场景上有一些不同之处。

ArrayDeque 是一个基于数组实现的双端队列，可以在队列的两端高效地进行插入和删除操作。ArrayDeque适用于以下场景：

队列和栈操作：ArrayDeque可以作为先进先出（FIFO）队列和后进先出（LIFO）栈来使用。它提供了add()、remove()、push()和pop()等方法来实现队列和栈的基本功能。

双端队列：ArrayDeque支持在队列的两端进行插入和删除操作，可以使用offerFirst()、pollFirst()、offerLast()和pollLast()等方法来实现双端队列的功能。

高性能要求：由于ArrayDeque是基于数组实现的，不涉及指针的操作，因此在插入和删除操作上具有较高的性能。相比于LinkedList，ArrayDeque在大部分场景下性能更好。

需要注意的是，ArrayDeque不是线程安全的，如果在多线程环境下使用，需要进行额外的同步控制。

ArrayList 是一个动态数组，可以自动扩展容量，适用于以下场景：

随机访问：ArrayList通过索引可以快速访问元素，支持随机访问操作，即通过索引直接访问某个位置的元素。这使得ArrayList适用于需要频繁访问指定位置元素的场景。

列表操作：ArrayList实现了List接口，提供了一系列方法来进行列表操作，如添加、删除、修改和查找元素等。它具有较好的灵活性和易用性。

动态扩展：ArrayList的容量可以根据需要自动扩展，因此在大部分情况下不需要担心容量问题。可以使用add()方法在末尾添加元素，也可以使用remove()方法删除指定位置的元素。

需要注意的是，ArrayList在频繁插入和删除元素时性能较差，因为插入和删除操作可能涉及到元素的移动。另外，ArrayList也不是线程安全的，如果在多线程环境下使用，需要进行额外的同步控制。

综上所述，如果需要在队列的两端进行高效的插入和删除操作，或者需要实现双端队列或栈的功能，可以选择ArrayDeque。如果需要随机访问元素，或者进行列表操作并且元素的插入和删除操作较少，可以选择ArrayList。

##### ConcurrentHashMap用到了哪些锁

ConcurrentHashMap是Java中的线程安全的哈希表实现。它在内部使用了一种称为"分段锁"（Segment Locking）的机制来提供并发性能。

具体来说，ConcurrentHashMap使用了多个锁（Segment），每个锁保护哈希表中的一部分数据，这样不同的线程可以同时访问不同的部分，从而提高并发性能。每个Segment类似于一个小的哈希表，其中包含了若干个键值对。

在Java 8之前的版本中，ConcurrentHashMap的分段锁使用了ReentrantLock（可重入锁）来实现。每个Segment都有一个关联的ReentrantLock对象，用于保护该Segment的操作。

从Java 8开始，ConcurrentHashMap的实现发生了变化。它引入了一种新的锁实现方式，即Striped64。Striped64通过一种更高效的方式来解决并发问题，并提供更好的扩展性和性能。

总结起来，ConcurrentHashMap使用了分段锁机制来实现并发控制，早期版本使用的是ReentrantLock，而Java 8及以后版本使用的是Striped64锁。这些锁用于保护ConcurrentHashMap内部的各个分段，确保线程安全的同时提供较高的并发性能。


##### ConcurrentHashMap的get方法里有做并发处理吗?

ConcurrentHashMap 的 get 方法之所以支持并发读取操作，并不是因为在 get 方法内部做了显式的并发处理，而是通过分段锁的设计，在更细粒度的层面上实现了并发控制。
这种设计使得在读多写少的场景下，ConcurrentHashMap 能够提供较好的性能表现，同时保证数据的一致性和线程安全性。


##### 数组元素的地址计算与数组的存储方式有关嘛？

在大多数情况下，数组元素的地址计算与数组的存储方式是相关的。具体而言，如果是连续存储方式（如C语言中的数组），那么数组元素的地址计算与数组的存储方式是相关的，因为元素在内存中是按照连续的地址存储的。

但如果是非连续存储方式（如链表等），则可能存在一些例外情况，数组元素的地址计算与数组的存储方式就不再完全相关了。


##### 二维数组的创建

定义二维数组时，不能省略第二维的大小，这是由编译器原理限制的。

##### 数组中的常见方法

push()方法可以在数组的末属添加一个或多个元素
shift()方法把数组中的第一个元素删除
unshift()方法可以在数组的前端添加一个或多个元素
pop()方法把数组中的最后一个元素删除


##### CopyOnWriteArrayList的底层实现原理

CopyOnWriteArrayList是Java并发包中提供的线程安全的List实现，其底层实现原理主要涉及"写时复制"机制。

写时复制机制：

当对CopyOnWriteArrayList进行修改操作（添加、删除、修改元素）时，不直接在原有的数组上进行操作，而是先将原数组进行复制，然后在新数组上进行修改操作。
这样做的好处是在修改过程中，读取操作仍然可以继续进行，读取操作会读取到原数组的内容，而修改操作则在新数组上进行，保证了并发读写的安全性。

并发性能：

CopyOnWriteArrayList适合在读操作远远多于写操作的场景下使用，因为写操作会导致数组的复制，可能会影响性能。
由于读操作不涉及加锁，所以可以并发进行，不会出现读写冲突的情况。

弱一致性：

CopyOnWriteArrayList提供的是一种弱一致性的保证，即在写操作完成之前，读操作可能仍然会读取到旧的数据。这是因为写操作会在新数组上进行，而读操作可能在旧数组上进行。
适用场景：

适用于读操作频繁，写操作较少的场景，例如事件监听器列表、缓存等。
不适合对实时性要求很高的场景，因为写操作会引入延迟。
总的来说，CopyOnWriteArrayList通过"写时复制"机制保证了在并发环境下的线程安全性，适用于特定的读多写少的场景。
需要根据具体业务需求和并发访问模式来选择是否使用CopyOnWriteArrayList。
