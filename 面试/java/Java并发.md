##### 说说对线程安全的理解

线程安全是指在多线程环境下，当多个线程同时访问某个对象或资源时，不会出现不可预料的结果或数据错乱，保证程序的正确性和稳定性。要实现线程安全，需要确保在并发访问情况下对共享资源进行合适的同步控制，以避免数据竞争和并发访问引起的问题。

一些常见的实现线程安全的方式包括：

加锁机制：通过使用锁（如synchronized关键字、ReentrantLock等）来保护共享资源，确保在同一时间只有一个线程可以访问共享资源，从而避免竞态条件。

原子操作：利用原子操作类（如AtomicInteger、AtomicReference等）来保证特定操作的原子性，从而避免多线程操作导致的数据不一致问题。

无锁数据结构：采用一些基于CAS（Compare And Swap）操作的无锁数据结构，如ConcurrentHashMap、CopyOnWriteArrayList等，来提供线程安全的操作。

线程封闭：将对象封装在线程内部，确保每个线程都拥有自己的对象实例，避免多线程共享同一对象带来的安全隐患。

使用线程安全的集合类：Java并发包提供了一系列线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等，可以直接使用这些类来避免并发访问问题。

总的来说，实现线程安全的关键在于合适的同步机制和数据访问策略，确保在多线程并发访问时能够保持数据的一致性和正确性。在编写多线程程序时，必须重视线程安全性，并使用合适的技术手段来保证程序的正确运行。

##### 对守护线程的理解

守护线程（Daemon Thread）是一种在后台提供服务的线程，它的作用是为其他线程提供一些服务或支持性工作。与普通线程不同的是，当所有的非守护线程结束时，守护线程会被强制终止，即使它正在执行一些任务。

守护线程通常用于在程序运行过程中执行一些辅助性质的任务，比如垃圾回收线程、定时任务监控线程等。这些线程通常不处理关键性任务，而是为整个程序提供一些技朋性的支持。

在Java中，通过Thread类的setDaemon()方法可以将一个线程设置为守护线程。一旦一个线程被设置为守护线程，在启动它之前必须调用setDaemon()方法，否则会抛出IllegalThreadStateException异常。当所有的非守护线程结束时，虚拟机会自动关闭所有的守护线程。

需要注意的是，守护线程并不应该执行可能会导致数据丢失或损坏的操作，因为在主线程执行完毕后，守护线程可能会被立即终止，未完成的操作可能会导致不可预料的结果。

总的来说，守护线程在Java中是一种辅助性质的线程，用于为程序提供支持性的服务，它会随着程序的结束而自动终止，不需要手动管理其生命周期。

##### synchronized 和 ReentrantLock区别

用法不同：synchronized 可以用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用于代码块。
获取锁和释放锁的机制不同：synchronized 是自动加锁和释放锁的，而 ReentrantLock 需要lock和unlock,手动加锁和释放锁。
锁类型不同：synchronized 是非公平锁，而 ReentrantLock 默认为非公平锁，也可以手动指定为公平锁。
响应中断不同：ReentrantLock 可以lockInterruptibly响应中断，解决死锁的问题，而 synchronized 不能响应中断。
底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。

##### Synchronized的底层实现原理
synchronized的底层实现是完全依赖JVM虚拟机的,所以谈synchronized的底层实现，就不得不谈数据在JVM内存的存储：Java对象头，以及Monitor对象监视器。
1.Java对象头

在JVM虚拟机中，对象在内存中的存储布局，可以分为三个区域:

对象头(Header)
实例数据(Instance Data)
对齐填充(Padding)

其中对象头包括两部分：
   1)类型指针（Klass Pointer）
   
   是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例;
   
   2)标记字段(Mark Word)
   
   用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等,它是实现轻量级锁和偏向锁的关键.
   
   所以，很明显synchronized使用的锁对象是存储在Java对象头里的标记字段里。
   
   2.Monitor
   
   monitor描述为对象监视器,可以类比为一个特殊的房间，这个房间中有一些被保护的数据，monitor保证每次只能有一个线程能进入这个房间进行访问被保护的数据，
   进入房间即为持有monitor，退出房间即为释放monitor。
  
 使用syncrhoized加锁的同步代码块在字节码引擎中执行时，主要就是通过锁对象的monitor的取用(monitorenter)与释放(monitorexit)来实现的。
 
##### ReentrantLock底层实现原理




##### java死锁如何避免

避免嵌套锁：尽量避免在持有一个锁的情况下去申请另一个锁。如果必须使用多个锁，尽量确保获取锁的顺序是一致的，避免出现循环依赖。

锁定顺序：为了避免死锁，可以规定获取锁的顺序，所有线程都按照相同的顺序获取锁。这样可以避免因为不同的锁获取顺序导致的死锁发生。

加锁时限：对于某些锁，可以设置一个超时时间，在获取锁的过程中如果超过了设定的时限仍然没有成功获取到锁，就放弃获取锁，并释放已经持有的锁，避免造成死锁。

死锁检测：通过（jConsole,jStack工具）定期检测系统中是否存在死锁的情况，可以采取措施解除死锁，如中断某个线程、回滚操作等。

合理设计线程交互：在设计多线程程序时，要合理设计线程之间的交互方式，避免产生潜在的死锁情况。

使用并发工具类：Java提供了一些并发工具类，如ConcurrentHashMap、ConcurrentLinkedQueue等，它们是线程安全的，并且避免了死锁的可能性。尽量使用这些类来代替自己手动管理锁的情况。

##### ReentrantLock中tryLock()和lock()方法的区别

ReentrantLock中的tryLock()和lock()方法都是用于获取锁的方法，它们之间的主要区别在于获取锁的方式和行为：

lock()方法：

lock()方法是ReentrantLock类中用于获取锁的基本方法，它会一直阻塞当前线程，直到获取到锁为止。如果获取锁失败，当前线程会被阻塞，直到获取到锁为止，这样可能会导致线程长时间等待，尤其在多线程竞争激烈的情况下。
tryLock()方法：

tryLock()方法是尝试获取锁的方法，它会立即返回获取锁的结果。如果获取成功，则返回true；如果获取失败（即锁已被其他线程持有），则立即返回false，而不会阻塞当前线程。tryLock()方法还可以传入超时时间参数，表示在指定的时间内尝试获取锁，如果超时仍未获取到锁，则返回false。
因此，tryLock()方法相比于lock()方法更具灵活性，能够避免线程长时间等待，适用于一些需要快速响应的场景。在使用tryLock()方法时，通常需要根据返回值来判断是否获取到了锁，并根据具体情况作出相应的处理，比如等待一段时间后重试、放弃获取锁或执行备选方案等。

总之，lock()方法是一种阻塞式的获取锁的方式，而tryLock()方法是一种非阻塞式的获取锁的方式。

##### 谈谈你对AQS的理解，以及AQS如何实现可重入锁

AQS（AbstractQueuedSynchronizer）是Java中用于实现同步器的抽象基类，它提供了一种机制，可以方便地实现各种类型的同步器，如锁、信号量、倒计时门栓等。AQS内部通过一个FIFO（先进先出）的等待队列来管理线程的竞争关系，通过状态变量来表示资源的占用情况。

AQS的核心思想是通过一个int类型的状态变量来表示资源的占用情况，当状态为0时表示资源未被占用，大于0时表示资源被占用。当多个线程同时竞争一个资源时，只有一个线程能成功占用资源，其他线程需要进入等待状态。AQS使用了一些原子操作来保证对状态变量的安全访问，如CAS（Compare and Swap）。

AQS实现可重入锁的方式是通过继承AQS类并重写相关方法来实现。可重入锁是指同一个线程在持有锁的情况下可以再次获取该锁而不会产生死锁。AQS提供了两个方法来支持可重入性：

tryAcquire(int arg)：尝试获取锁，如果成功则返回true，失败则返回false。在可重入锁的实现中，可以通过判断当前线程是否已经持有锁，如果是则增加锁的计数；如果不是则进行正常的锁获取操作。

tryRelease(int arg)：尝试释放锁，如果成功则返回true，失败则返回false。在可重入锁的实现中，可以通过判断当前线程是否已经持有锁，如果是则减少锁的计数；如果不是则进行正常的锁释放操作。

通过这种方式，AQS实现了可重入锁的语义。当一个线程多次获取锁时，只需增加锁的计数，当线程释放锁时，只需减少锁的计数，直到计数为0时锁才完全释放。这样就保证了同一个线程在持有锁的情况下可以再次获取该锁，而其他线程需要等待。

总之，AQS是Java中用于实现同步器的抽象基类，通过状态变量和等待队列来管理线程的竞争关系。通过继承AQS并重写相关方法，可以实现各种类型的同步器，包括可重入锁。通过增加锁的计数和减少锁的计数，AQS实现了可重入锁的语义，确保同一个线程可以多次获取同一个锁而不会产生死锁。

##### HashMap为什么不安全？

竞态条件（Race Condition）：由于HashMap的put和get等操作不是原子性的，多个线程同时对HashMap进行put操作时，可能会导致数据覆盖或丢失的情况发生。

死锁（Deadlock）：在并发环境下，如果多个线程同时对HashMap中的数据进行操作，并且操作顺序不当，可能会导致死锁的发生。

ConcurrentModificationException：在一个线程正在遍历HashMap的同时，另一个线程对HashMap进行结构性修改（如put、remove操作），可能导致迭代器抛出ConcurrentModificationException异常。

##### ThreadLocal的使用场景
用来实现相同线程数据共享不同的线程数据隔离，但是注意，由于ThreadLocal底层使用的是ThreadLocalMap,这个Map的key是弱引用，value是强引用，生命周期与Thread相同，
所以只有在Thread退出后，value的强引用链条才会断掉，如果当前线程不结束，则无法被回收，造成泄露。所以使用ThreadLocal需要及时remove否则会引起内存泄露