##### 关系型数据库 VS 非关系型数据库——SQL DB 和 NoSQL DB 的区别
关系数据库（或 SQL 数据库）已经存在了一段时间。第一个关系数据库出现在 1970 年，关系数据库至今仍然很流行，一些最常见的如：

PostgreSQL
Microsoft SQL Server
MySQL
Oracle
SQLite

关系型数据库的特点：
是表格格式
非常有条理，并且数据以某种结构存储
具有严格、预定义的架构
使用 SQL 执行数据库查询和操作数据
关系数据库的ACID属性

非关系数据库

由于关系数据库已无法满足互联网海量且复杂的数据，所以NoSQL开始变得流行。流行的非关系数据库包括：
MongoDB
Redis
Apache Cassandra
Google Cloud Bigtable
Amazon DynamoDB

非关系数据库主要包括四种：
列式数据库
键-值数据库
面向文档的数据库
图数据库

文档型数据库：以文档为单位存储数据，每个文档可以包含不同的字段和数据类型。代表性的文档型数据库包括MongoDB和Couchbase。

列式数据库：数据以列族的形式存储，适合于需要大量并行读取的场景，如数据仓库和分析。代表性的列式数据库包括Apache HBase和Apache Cassandra。

键值对数据库：以键值对的形式存储数据，适合于快速存取数据。代表性的键值对数据库包括Redis和DynamoDB。

图形数据库：用于存储图结构数据，能够高效地处理复杂的关联关系。代表性的图形数据库包括Neo4j和Amazon Neptune。



##### 一条 SQL 执行的全流程
      
一条SQL语句的执行过程可以简单分为以下几个步骤：

语法解析：数据库首先对SQL语句进行词法分析和语法分析，将SQL语句解析成一个语法树（parse tree）或者抽象语法树（abstract syntax tree）。这一步会检查语句的语法是否正确。

查询优化：对于查询语句（如SELECT），数据库会进行查询优化，即选择最优的执行计划。这包括确定表的访问顺序、选择合适的索引、决定连接方式等。数据库优化器会根据统计信息、索引信息和系统配置等因素进行评估，并生成执行计划。

执行计划生成：根据查询优化阶段生成的执行计划，数据库会生成实际的执行计划。执行计划描述了如何从存储中获取数据并进行处理，包括执行的操作、访问的表和索引、连接方式等。

数据获取：根据执行计划，数据库开始执行查询操作。这涉及到表的扫描、索引的查找以及可能的连接操作等。数据库会按照执行计划的要求逐步获取所需的数据。

数据处理：获取到数据后，数据库会对数据进行相应的处理，如排序、聚合、连接、过滤等。这一步是根据SQL语句中的具体操作进行的。

结果返回：处理完成后，数据库将执行结果返回给客户端。对于查询语句，返回的是查询结果集；对于更新语句（如INSERT、UPDATE、DELETE），返回的是受影响的行数。

事务处理：如果SQL语句在一个事务中执行，数据库还会进行相应的事务处理，包括事务的开始、提交或回滚等操作。事务处理保证了数据的一致性和完整性。

需要注意的是，每个数据库管理系统（DBMS）的具体实现方式可能有所不同，上述步骤只是一般的执行流程示意，并不能代表所有情况。此外，数据库还会涉及到锁机制、并发控制、日志记录等其他重要的组成部分，以保证数据的安全和可靠性。


##### MySQL聚合函数
 包括： AVG,COUNT,MAX,MIN,SUM,需要注意的是,除了COUNT外，其他聚合函数会在执行时忽略NULL值。

##### select......for update会锁表还是锁行？
如果查询条件用了索引/主键，那么select ..... for update就会进行行锁。
如果是普通字段(没有索引/主键)，那么select ..... for update就会进行锁表。

##### MySQL，Oracle的基本数据类型
字符类型（Character types）：包括CHAR、VARCHAR、TEXT等。其中CHAR是固定长度的字符类型，VARCHAR是可变长度的字符串类型，TEXT用于存储较大的文本数据。

数值类型（Numeric types）：包括整数类型INT、BIGINT、SMALLINT、TINYINT等，以及浮点数类型FLOAT、DOUBLE和DECIMAL。

日期和时间类型（Date and time types）：包括DATE、TIME、DATETIME、TIMESTAMP等。

date ：“yyyy-mm-dd”格式表示的日期值
time ：“hh:mm:ss”格式表示的时间值
datetime：“yyyy-mm-dd hh:mm:ss”格式
timestamp：“yyyymmddhhmmss”格式表示的时间戳值

布尔类型（Boolean types）：MySQL中使用TINYINT(1)来表示布尔值，Oracle中使用NUMBER(1)表示。

二进制类型（Binary types）：包括BLOB和LONGBLOB等，用于存储二进制数据。

枚举类型（Enum types）：MySQL支持ENUM类型，用于定义一组枚举值；Oracle中可以使用CHECK约束实现类似的功能。

集合类型（Set types）：MySQL支持SET类型，用于存储一组不重复的字符串；Oracle中可以使用VARRAY实现类似的功能。

Oracle基本数据类型：
 一、字符串类型
 字符串数据类型还可以依据存储空间分为固定长度类型（CHAR/NCHAR) 和可变长度类型（VARCHAR2/NVARCHAR2)两种.
 
 所谓固定长度：是指虽然输入的字段值小于该字段的限制长度，但是实际存储数据时，会先自动向右补足空格后，才将字段值的内容存储到数据块中。
 这种方式虽然比较浪费空间，但是存储效率较可变长度类型要好。同时还能减少数据行迁移情况发生。
 
 所谓可变长度：是指当输入的字段值小于该字段的限制长度时，直接将字段值的内容存储到数据块中，而不会补上空白，这样可以节省数据块空间。
1.CHAR类型(size[BYTE | CHAR])

##### 行链接和行迁移

行链接是指表中的行太大，超出了一个块的容量，导致一个行片段要在多个数据块中存储。

行迁移是指在更新后，原有块不能提供长度增加后新的行片段的空间要求，此时数据库会将整个行的数据迁移到新数据块中，原有行片段的空间保留并指向行迁移的新块，行迁移的ROWID不变。

当行链接或行迁移后，访问这些行时必须要扫描多个数据块才能检索到该行的信息，因此与此行关联的I/O性能会降低。


##### Oracle CHAR(12 BYTE) 和 CHAR(12 CHAR)区别？
CHAR(12 BYTE) 意味着该列将存储 12 个字节的数据。
在这种情况下，Oracle 将以字节为单位计算长度，无论实际存储的是字符还是其他数据。
如果使用单字节字符集（如ASCII），那么 12 个字符将占用 12 个字节的存储空间。

CHAR(12 CHAR) 意味着该列将存储 12 个字符的数据。
在这种情况下，Oracle 将以字符为单位计算长度，并考虑字符集的多字节性质。
如果使用多字节字符集（如UTF-8），那么 12 个字符可能会占用超过 12 个字节的存储空间，具体取决于字符集和编码方式。

例如存储中文的情况，对于UTF-8编码，CHAR(12 CHAR)可以存储12个中文，CHAR(12 BYTE) 只能存储4个中文，如果是UTF-16编码，则一个中文占用2个字节，则可以存储6个中文。

##### 如果MySQL 中定义CHAR(12 CHAR)，可以存储几个中文
      
CHAR(12 CHAR) 中的长度是以字符为单位计算的，会考虑字符集的多字节性质。所以可以存储12个中文。

##### 数据库怎么设置字符的编码字符集
      
MySQL:
  SHOW VARIABLES LIKE 'character_set_%'; 
  修改字符集:
  SET character_set_server = utf8;
   -- 这个命令只会改变显示问题，底部的database的编码还是不会因为这个命令而受到影响的
   (在MySQL中所有字符都是使用 ASCII 码编码的。当用户执行数据插入或查询操作时，MySQL 会自动将用户输入的字符转换为 ASCII 码编码，然后在存储和处理数据时使用 ASCII 码编码进行计算和处理。)。

Oracle:

  查询数据库字符集：
  SELECT value FROM nls_database_parameters WHERE parameter = 'NLS_CHARACTERSET';
  查看客户端字符集：
  SELECT USERENV('language') FROM DUAL;
  
  Oracle不支持修改已经创建的表的字符集：
  CREATE DATABASE mydatabase CHARACTER SET utf8;
  
  另外注意：在Linux系统与Windows系统中，server和system以及database的编码发现Linux下的都是Latin1，而windows下的这个都是utf8。


##### Explain 分析：

EXPLAIN语句是MySQL中用于查询执行计划分析和优化的关键字。它可以帮助我们理解查询的执行方式，并根据执行计划进行性能优化。

使用EXPLAIN语句时，我们需要在要执行的SELECT查询语句前加上EXPLAIN关键字，例如：

sql
EXPLAIN SELECT * FROM table_name WHERE condition;
EXPLAIN语句执行后，会返回一张表格，其中包含了查询的执行计划的详细信息。以下是EXPLAIN结果表格中的一些重要字段和解释：

id：查询的标识符，每个查询都有一个唯一的标识符，可以用于标识子查询。
select_type：表示查询的类型，常见的值有SIMPLE（简单查询）、PRIMARY（最外层查询）、SUBQUERY（子查询）等。
table：表示查询涉及的表名。
type：表示访问表的方式，常见的值有ALL（全表扫描）、INDEX（索引扫描）、RANGE（范围扫描）等。
possible_keys：表示可能使用的索引。
key：表示实际使用的索引。
key_len：表示使用的索引的长度。
ref：表示与索引比较的列或常量。
rows：表示扫描的行数。
Extra：包含附加信息，如Using where（使用了WHERE条件）、Using index（使用了索引）等。
通过分析EXPLAIN的结果，我们可以判断查询是否使用了索引、是否存在全表扫描、是否有性能瓶颈等，从而进行优化。以下是一些常见的优化思路：

确保查询列都有合适的索引，避免全表扫描。
尽量减少ALL类型的查询，考虑使用索引或者优化查询条件。
注意JOIN操作的执行计划，确保关联字段有索引。
根据实际情况调整查询顺序，尽量减少中间结果集的大小。
分析Extra字段，检查是否存在不必要的操作，如Using temporary、Using filesort等，并考虑优化方式。

在MySQL的EXPLAIN结果中，Extra字段提供了一些额外的信息，用于帮助我们更好地理解查询的执行计划。下面是一些常见的Extra值及其解释：

Using index：表示查询已经覆盖了所需的列，只使用了索引而不需要进一步查找行数据。
Using where：表示查询使用了WHERE条件过滤数据。
Using temporary：表示MySQL在执行查询时使用了临时表来处理结果集，通常是由于排序（ORDER BY）或分组（GROUP BY）操作导致的。
Using filesort：表示MySQL需要进行文件排序来满足排序要求，这通常发生在没有合适的索引支持排序操作时。
Using join buffer：表示MySQL使用了连接缓冲区来处理连接操作。
Using index condition：表示查询使用了索引条件推送优化，即将WHERE条件中的部分逻辑推送到索引访问过程中。
Range checked for each record：表示MySQL在使用索引范围扫描时，对每条记录进行额外的检查，以验证是否满足查询条件。
Full scan on NULL key：表示在进行索引范围扫描时，遇到了空值的情况。
Distinct：表示MySQL在执行查询时需要去重。
Impossible where：表示WHERE条件中的谓词逻辑不可能为真，因此查询将返回空结果。
No tables used：表示查询没有涉及到任何表，通常是由于直接从系统表中获取信息或使用了用户变量等情况。

 ##### 为什么MySQL不建议使用NULL作为列默认值？
 
 查询复杂性：当一个列的默认值设置为NULL时，在查询数据时需要考虑NULL值的情况，这会增加查询的复杂性。在编写SQL查询语句时，必须使用特殊的语法或函数来处理NULL值，例如使用IS NULL或IS NOT NULL进行条件判断。这样会增加代码的复杂性和维护成本。
 
 不一致性和歧义：NULL值的含义比较模糊，它可以表示缺失的数据、未知的数据或不适用的数据。当将NULL作为列的默认值时，可能会导致数据的不一致性和歧义。例如，对于一个年龄字段，默认值为NULL可能被误解为缺失了年龄信息，而实际上可能只是该字段不适用于特定的记录。
 
 索引效率：对于包含NULL值的列，MySQL的索引可能会变得更大、更复杂，从而影响查询的效率。当NULL作为默认值时，如果该列被包含在索引中，那么索引树必须包含额外的信息来表示NULL值，这会增加索引的大小和维护成本。
 
 ##### MySQL 有哪些锁？
       
共享锁（Shared Lock）：也称为读锁（Read Lock），多个事务可以同时持有共享锁，用于并发读取数据，互不干扰。共享锁之间是兼容的，即多个事务可以同时持有共享锁。

排他锁（Exclusive Lock）：也称为写锁（Write Lock），排他锁是独占的，一次只能有一个事务持有排他锁。排他锁用于对数据进行修改，其他事务无法同时持有共享锁或排他锁。

记录锁（Record Lock）：在InnoDB存储引擎中，记录锁用于锁定某一行的数据，可以是共享锁或排他锁。当事务需要修改某一行的数据时，会获取该行的排他锁，其他事务无法同时获取该行的排他锁或共享锁。而当事务需要读取某一行的数据时，会获取该行的共享锁，其他事务可以获取该行的共享锁，但不能获取排他锁。

表锁（Table Lock）：表级锁，对整个表进行锁定，一次只能有一个事务持有该表的锁。表锁是最粗粒度的锁，对并发性能影响较大，一般在需要全表操作时才使用。

间隙锁（Gap Lock）：在InnoDB存储引擎中，间隙锁用于锁定一个范围的键值之间的间隙，防止其他事务插入新的记录到该范围内。间隙锁用于解决幻读问题。

外键约束锁（Foreign Key Constraint Lock）：在InnoDB存储引擎中，外键约束锁用于维护外键约束的完整性。当插入、修改或删除涉及到外键的数据时，会获取相应的外键约束锁。

##### 数据库的数据库ACID

原子性（Atomicity）：事务被视为不可分割的最小操作单元，要么全部执行成功，要么全部失败回滚。如果事务操作成功提交，那么所有的修改将永久保存；如果失败回滚，所有的修改将撤销，数据库回到事务开始之前的状态。

一致性（Consistency）：事务将数据库从一个一致性状态转换到另一个一致性状态。在事务开始之前和结束之后，数据库必须保持一致性状态，确保数据的完整性约束、业务规则等不会被破坏。

隔离性（Isolation）：多个事务并发执行时，每个事务都应该被隔离开来，互不影响。这意味着一个事务的执行不能被其他事务干扰，确保各个事务之间的相互独立性。

持久性（Durability）：一旦事务成功提交，其所做的修改将永久保存在数据库中，即使系统发生故障或重启，数据也不会丢失。


##### mysql给表增加外键语句写法
      
ALTER TABLE 表名
ADD CONSTRAINT 外键约束名
FOREIGN KEY (外键列名) REFERENCES 关联表名(关联列名);

##### Oracle与MySQL有哪些语句上的区别

1、SQL 语法差异：

Oracle 中使用双引号来引用标识符（如表名、列名），而 MySQL 使用反引号（`）或者直接不使用引号。
在日期和时间处理上，Oracle 使用 TO_DATE()、TO_CHAR() 等函数，而 MySQL 使用 DATE_FORMAT()、STR_TO_DATE() 等函数。
在字符串连接上，Oracle 使用 || 运算符，MySQL 使用 CONCAT() 函数。
在分页查询上，Oracle 使用 ROWNUM 或者 ROW_NUMBER()，MySQL 使用 LIMIT。
2、数据类型差异：

Oracle 和 MySQL 支持的数据类型有些许差异，比如 Oracle 中有 RAW 类型，MySQL 中没有；MySQL 中有 SET 和 ENUM 类型，Oracle 中没有。
在处理字符串长度时，Oracle 中 VARCHAR2 最大长度为 4000 字节，MySQL 中 VARCHAR 最大长度为 65535 字节（UTF-8 编码下）。
3、存储过程和触发器：

Oracle 和 MySQL 在存储过程和触发器的语法和特性上有一些差异，尤其是在变量声明、异常处理、事务控制等方面。
4、自增字段：

在自增字段的处理上，Oracle 使用序列（Sequence）与触发器（Trigger）结合，而 MySQL 直接使用 AUTO_INCREMENT 属性。

##### 如果WHERE子句中使用了索引，那么ORDER BY子句会不会使用索引

在数据库查询中，当WHERE子句中使用了索引，而ORDER BY子句中也包含了相同的字段时，数据库优化器的行为可以取决于具体的数据库管理系统。
一般来说，如果WHERE子句中使用了索引，数据库可能会利用该索引进行数据检索和过滤，但不保证在ORDER BY子句中也会使用同一个索引。

在某些情况下，数据库优化器可能会选择对ORDER BY子句中的字段重新排序，而不是利用已存在的索引。
这是因为排序操作可能需要不同的排序算法或者特定的索引结构才能高效执行，而原先的索引并不一定适合排序操作。

因此，虽然WHERE子句中使用了索引，但并不能保证ORDER BY子句也会使用索引。在实际应用中，为了提高查询性能，
可以考虑在经常用于排序的字段上创建单独的排序索引，以确保ORDER BY操作的高效执行。
    
    
##### 索引为什么选B+树，而不是跳表？

B+树：
  B+树一般由多个页、多层级组成，在MySQL中每个页 16 kb。
  主键索引的 B+ 树的叶子结点才是数据，非叶子结点存放的是索引信息
  上下层的页通过单指针相连
  同一层级的相邻的数据页通过双指针相邻

跳表：
   跳表的结构就像是由单链表结构衍生出来的，但是它的效率却比普通的单链表高上很多
   跳表的最底层是单链表，但是跳表也是具有多层级的
   

MySQL选用 B+ 树构建索引，主要是因为 B+ 树是多叉结构，而且根据它结构组织数据页/索引页，存放2kw数据也只是需要 3 层左右就可以了，
目前实践中，B+树索引几乎没有超过 4 层，换句话说，如果是 B+ 树索引的话，查找一次数据，一般最多也就 3 次磁盘 IO ；

而在跳表中就不一样了，2kw的数据在跳表中存储，如果想要达到二分查找的效率的话，最起码也要2^24层级才能实现，
而每个层级的数据都是分散在不同的数据页中的，所以在查找数据的过程中，跳表可能需要进行 24次磁盘IO。


##### 为什么数据库字段建议设置not null

数据完整性：通过将字段设置为 NOT NULL，可以强制要求在插入和更新数据时必须提供非空值。这样可以避免数据库中出现不完整或不一致的数据，确保数据的完整性。

查询性能：对于包含大量 NULL 值的列，数据库需要额外的空间来存储 NULL 值，并且对查询性能也会有一定的影响。如果将字段设置为 NOT NULL，可以减少存储空间的使用，并且查询时也不需要额外处理 NULL 值。

代码简化：在应用程序中，如果数据库字段设置为 NOT NULL，可以省去对空值的处理逻辑，简化代码的编写。这样可以提高代码的可读性和可维护性。

约束和规范：将字段设置为 NOT NULL 可以作为定义表结构的一种约束和规范，使得数据库设计更加规范化和一致化。这样可以降低数据错误和数据冲突的风险。

##### Mysql与PL/SQL有什么区别

PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。
在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。

MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，
在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。

MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

sql server，PL/SQL，mysql区别为：性质不同、数据类型不同、面向群不同。

一、性质不同

PL/SQL：PL/SQL是一种过程化语言，是Oracle数据库对SQL语句的扩展。

mysql：mysql是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。

二、数据类型不同

PL/SQL：PL/SQL能够利用Web的多媒体特性，将在Web中发现的各种数据类型集成为数据包（mess）。

mysql：mysql能够将非传统的数据存储到单独的服务器里的平面（flat）文件中，然后使用OLE-DB将它们链接在一起。

三、面向群不同

PL/SQL：PL/SQL的面向群体为商业化大型企业。

mysql：mysql的面向群体为一般的个人使用者和中小型企业

##### MongoDB/HBase/Redis

MongoDB  适用于数据读性能要求高，表结构变化大，数据规模较大、需要聚合查询的场景
HBase 适用于大数据量持久化存储场景
Redis 适用于读写要求高，数据量较小并且不需要持久化的场景


MongoDB - 开源，无模式的文档型数据库，开发语言是C++。可用于替代传统的关系型数据库或键/值存储方式。

##### MySQL的binlog
mysql 四大日志之一、二进制文件

可以用于实现主从复制、数据同步(同步到Hbase、ES,kafka)、数据恢复、SQL审计

##### MySQL 常用引擎有哪些？

1.InnoDB
InnoDB 是 MySQL 5.1 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列。如果对业务的完整性要求较高，比如张三给李四转账，需要减张三的钱，同时给李四加钱，这时候只能全部执行成功或全部执行失败，此时可以通过 InnoDB 来控制事务的提交和回滚，从而保证业务的完整性。

优缺点分析
InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大。

2.MyISAM
MyISAM 是 MySQL 5.1 之前默认的数据库引擎，读取效率较高，占用数据空间较少，但不支持事务、不支持行级锁、不支持外键等特性。因为不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。

优缺点分析
MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。但它不支持事务、不支持外键，所以它的适用场景是读多写少，且对完整性要求不高的业务场景。

3.MEMORY
内存型数据库引擎，所有的数据都存储在内存中，因此它的读写效率很高，但 MySQL 服务重启之后数据会丢失。它同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。而前面两种存储引擎是基于 B+ 树的数据结构实现了。

优缺点分析
MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。

##### select for update使用

一、for update定义

for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。

只有当出现如下之一的条件，才会释放共享更新锁：
1、执行提交（COMMIT）语句
2、退出数据库（LOG　OFF）
3、程序停止运行

 

二、概念和用法

通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。

而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键，会锁行数据，如果没有，会锁表。

 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。

举个例子: 假设有张表user ，里面有 id 和 name 两列，id是主键。

 

例1: (明确指定主键，并且数据真实存在，row lock)

SELECT * FROM user WHERE id=3 FOR UPDATE;

SELECT * FROM user WHERE id=3 and name='Tom' FOR UPDATE;
 

例2: (明确指定主键，但数据不存在，无lock)

SELECT * FROM user WHERE id=0 FOR UPDATE;
 

例3: (主键不明确，table lock)

SELECT * FROM user WHERE id<>3 FOR UPDATE;

SELECT * FROM user WHERE id LIKE '%3%' FOR UPDATE;
 

例4: (无主键，table lock)

SELECT * FROM user WHERE name='Tom' FOR UPDATE;
 

注意：
1、FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。

2、要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。

3、Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。

 

三、什么时候需要使用for update？

借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。

场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。

 

四、for update悲观锁

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。


##### MySQL事务的隔离级别
 READ UNCOMMITTED（未提交读）
   在这种事务级别中，事务中的修改即使没有提交，对其他事务也是可见的，事务可以读取未提交的数据，这也被称为"脏读"，这种级别会有脏读、不可重复读、幻读问题。
   
 READ COMMITTED（提交读）
   大多数数据库的事务隔离级别就是这种，比如Oracle，简单定义就是：一个事务开始时，只能看见已经提交的事务所做的修改，这个级别也叫做"不可重复读"，存在不可重复读、幻读问题。
   
 REPEATABLE READ（可重复读）
   MySQL的默认事务隔离级别，解决了脏读问题，但是理论上存在幻读问题，这个问题使用InnoDB和XtraDB存储引擎的话，通过加间隙锁的方式解决了幻读问题。
   
 SERIALIZABLE(可串行化)
   会在读取的每一行数据上都加锁，所以会导致大量的超时和锁等待问题，不推荐使用。
   
 另外，在MySQL中，READ COMMITTED（提交读）和REPEATABLE READ（可重复读）解决幻读、不可重复读问题，使用的是乐观锁-MVCC(多版本并发控制)的方式解决的。
 
##### MVCC如何解决脏读、不可重复读问题？
   1.MVCC是行级锁的一个变种、在很多情况下避免了加锁操作，因此开销更低，写操作也只锁定必要的行。
   2.MVCC的实现，是通过保存数据在某一个时间点的快照实现的。
 
 不同存储引擎的实现方式不同，重点介绍下InnoDB如何实现MVCC的：
   MVCC通过在每行记录后面保存两个隐藏的列来实现，一个是行的创建时间，另一个是行的过期时间(或者删除时间)，存储的也不是实际值，而是系统版本号。
   具体操作：
      SELECT:
        InnoDB根据以下两个条件检查每行记录：
        a. InnoDB只查找版本早于当前事务版本的数据行(行的版本号小于等于事务的系统版本号)，这样保证事务读取的行，要么在事务开启前，要么事务本身自己插入或修改的。
        b.行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行，在当前事务开启前没有被删除。
      INSERT:
        InnoDB为新插入的每一行保存当前系统版本号。
      DELETE：
        为删除的每行保存当前系统的版本号作为行删除标识。
      UPDATE:
        InnoDB为插入一行新的记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。
   
 MVCC只能在READ COMMITTED（提交读）和REPEATABLE READ（可重复读）两个隔离级别下工作，其他不兼容。
 
 ##### MySQL的普通索引和唯一索引到底什么区别？
 
 普通索引 V.S 唯一索引
 普通索引可重复，唯一索引和主键一样不能重复。
 唯一索引可作为数据的一个合法验证手段，例如学生表的身份证号码字段，人为规定该字段不得重复，那么就使用唯一索引。（一般设置学号字段为主键）
 
 主键 V.S 唯一索引
 主键保证DB的每一行都是唯一、不重复，比如身份证，学号等，不重复。
 唯一索引的作用跟主键一样。
 但在一张表里面只能有一个主键，不能为空，唯一索引可有多个。唯一索引可有一条记录为null。
 
 
 ##### MySQL数据类型
 
 MySQL 支持多种数据类型，主要有数值类型、日期/时间类型和字符串类型。
 
 数值类型：包括整数类型 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT、浮点小数数据类型 FLOAT和 DOUBLE、定点小数类型 DECIMAL。
    MySQL中的整数型数据类型：
    
    类型名称	存储需求
    TINYINT	1个字节
    SMALLINT	2个字节
    MEDIUMINT	3个字节
    INT(INTEGER)	4个字节
    BIGINT	8个字节
    
    浮点数类型和定点数类型
    类型名称	说明	存储需求
    FLOAT	单精度浮点数	4个字节
    DOUBLE	霜精度浮点数	8个字节
    DECIMAL(M,D)	压缩的“严格”定点数	M+2个字节
    
 日期/时间类型：YEAR 、TIME、 DATE、 DATETIME 和 TIMESTAMP。
 
   日期与时间类型
   类型名称	日期格式	日期范围	存储需求
   YEAR	YYYY	1901~2155	1个字节
   TIME	HH:MM:SS	-838:59:59~838:59:59	3个字节
   DATE	YYYY-MM-DD	1000-01-01~9999-12-3	3个字节
   DATETIME	YYYY-MM-DD HH:MM:SS	1000-01-01 00:00:00~9999-12-31 23:59:59	8个字节
   TIMESTAMP	YYYY-MM-DD HH:MM:SS	1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC	4个字节
   
 字符串类型： CHAR 、VARCHAR、 BINARY、 VARBINARY、 BLOB、 TEXT、 ENUM、 SET 。
   字符串类型
   类型名称	说明	存储需求
   CHAR(M)	固定长度非二进制字符串	M字节，1<=M<= 255
   VARCHAR(M)	变长非二进制字符串	L+1字节，L<=M和1<=M<=255
   TINYTEXT	非常小的非二进制字符串	L+1字节，在此L<2^8
   TEXT	小的非二进制字符串	L+2字节，在此L<2^16
   MEDIUMTEXT	中等大小的非二进制字符串	L+3字节，在此L<2^32
   LONGTEXT	大的非二进制字符串	L+4字节，在此L<2^32
   ENUM	枚举类型，只能存一个枚举字符串值	1或2个字节，取决于枚举值的数目（最大值65535）
   SET	一个设置，字符串对象可以有零个或多个 SET 成员	1、2、3、4或8个字节，取决于集合成员的数量（最多64个成员）
   
 ##### Oracle基本数据类型
   ORACLE基本数据类型（亦叫内置数据类型 built-in datatypes)可以按类型分为：字符串类型、数字类型、日期类型、LOB类型、LONG RAW& RAW类型、ROWID & UROWID类型。
   
   一、字符串类型：
     1.1 ：CHAR类型 CHAR(size [BYTE | CHAR]) 
      CHAR类型，定长字符串，会用空格填充来达到其最大长度。非NULL的CHAR（12）总是包含12字节信息。CHAR字段最多可以存储2,000字节的信息。如果创建表时，
      不指定CHAR长度，则默认为1。另外你可以指定它存储字节或字符，例如 CHAR(12 BYTYE) CHAR(12 CHAR).一般来说默认是存储字节
     1.2： NCHAR类型
       这是一个包含UNICODE格式数据的定长字符串。NCHAR字段最多可以存储2,000字节的信息。它的最大长度取决于国家字符集。另外查询时，如果字段是NCHAR类型，则需要如下书写
       SELECT translated_description FROM product_descriptions
       WHERE translated_name = N'LCD Monitor 11/PM';
     1.3 VARCHAR类型
       不要使用VARCHAR数据类型。使用VARCHAR2数据类型。虽然VARCHAR数据类型目前是VARCHAR2的同义词，VARCHAR数据类型将计划被重新定义为一个单独的数据类型用于可变长度的字符串相比，具有不同的比较语义。
     1.4： VARCHAR2类型
       变长字符串，与CHAR类型不同，它不会使用空格填充至最大长度。VARCHAR2最多可以存储4,000字节的信息。
     1.5： NVARCHAR2类型
       这是一个包含UNICODE格式数据的变长字符串。 NVARCHAR2最多可以存储4,000字节的信息。
  二. 数字类型：
    2.1 NUMBER类型
    NUMBER(P,S)是最常见的数字类型，可以存放数据范围为10^130~10^126（不包含此值)，需要1~22字节(BYTE)不等的存储空间。
    P 是Precison的英文缩写，即精度缩写，表示有效数字的位数，最多不能超过38个有效数字
    S是Scale的英文缩写，可以使用的范围为-84~127。Scale为正数时，表示从小数点到最低有效数字的位数，它为负数时，表示从最大有效数字到小数点的位数
    
    2.2 INTEGER类型
    INTEGER是NUMBER的子类型，它等同于NUMBER（38,0），用来存储整数。若插入、更新的数值有小数，则会被四舍五入。
    
    2.3 浮点数
    
    浮点数可以有一个十进制数点任何地方从第一个到最后一个数字，或者可以在所有有没有小数点。指数可能（可选） 用于以下数量增加的范围 （例如， 1.777e-20)。刻度值不适用于浮点数字，因为可以显示在小数点后的位数的数量不受限制。
    
    二进制浮点数不同数量的值由 Oracle 数据库内部存储的方式。使用小数精度数存储值。完全相同号码存储范围和数量由支持的精度内的所有文本。正是因为使用小数精度（数字 0 到 9） 表示文本存储文本。使用二进制精度 （数字 0 和 1） 存储二进制浮点数。这种存储方案不能代表所有确切地使用小数精度的值。频繁地，将值从十进制转换为二进制的精度时出现的错误时撤消值回从二进制转换为十进制精度。在字面 0.1 是一个这样的例子。
    
    Oracle 数据库提供了专为浮点数的两种数值数据类型：
    
    BINARY_FLOAT
    
    BINARY_FLOAT 是 32 位、 单精度浮点数字数据类型。可以支持至少6位精度,每个 BINARY_FLOAT 的值需要 5 个字节，包括长度字节。
    
    BINARY_DOUBLE
    
    BINARY_DOUBLE 是为 64 位，双精度浮点数字数据类型。每个 BINARY_DOUBLE 的值需要 9 个字节，包括长度字节。
    
    在数字的列中，浮点数有小数精度。在 BINARY_FLOAT 或 BINARY_DOUBLE 的列中，浮点数有二进制的精度。二进制浮点数支持的特殊值无穷大和 NaN （不是数字）。
    
  三. 日期类型
  
  日期类型用于存储日期数据，但是并不是使用一般的格式（2012-08-08）直接存储到数据库的。
  
  3.1 DATE类型
  
  DATE是最常用的数据类型，日期数据类型存储日期和时间信息。虽然可以用字符或数字类型表示日期和时间信息，但是日期数据类型具有特殊关联的属性。为每个日期值，Oracle 存储以下信息： 世纪、 年、 月、 日期、 小时、 分钟和秒。一般占用7个字节的存储空间。
  
  3.2 TIMESTAMP类型
  
  这是一个7字节或12字节的定宽日期/时间数据类型。它与DATE数据类型不同，因为TIMESTAMP可以包含小数秒，带小数秒的TIMESTAMP在小数点右边最多可以保留9位
  
  3.3 TIMESTAMP WITH TIME ZONE类型
  
  这是TIMESTAMP类型的变种，它包含了时区偏移量的值
  
  3.4 TIMESTAMP WITH LOCAL TIME ZONE类型
  
  3.5 INTERVAL YEAR TO MOTH
  
  3.6 INTERVAL DAY TO SECOND
  
  四. LOB类型
  
  内置的LOB数据类型包括BLOB、CLOB、NCLOB、BFILE（外部存储）的大型化和非结构化数据，如文本、图像、视屏、空间数据存储。BLOB、CLOB、NCLOB类型
  
   
  
  4.1 CLOB 数据类型
  
     它存储单字节和多字节字符数据。支持固定宽度和可变宽度的字符集。CLOB对象可以存储最多 (4 gigabytes-1) * (database block size) 大小的字符
  
  4.2 NCLOB 数据类型
  
     它存储UNICODE类型的数据，支持固定宽度和可变宽度的字符集，NCLOB对象可以存储最多(4 gigabytes-1) * (database block size)大小的文本数据。
  
  4.3 BLOB 数据类型
  
     它存储非结构化的二进制数据大对象，它可以被认为是没有字符集语义的比特流，一般是图像、声音、视频等文件。BLOB对象最多存储(4 gigabytes-1) * (database block size)的二进制数据。
  
  4.4 BFILE 数据类型
  
     二进制文件，存储在数据库外的系统文件，只读的，数据库会将该文件当二进制文件处理
  
  五. RAW & LONG RAW类型
  
  六. ROWID & UROWID类型